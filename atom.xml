<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Pineapple]]></title>
  <subtitle><![CDATA[Record Something]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://blueanana.github.io/"/>
  <updated>2015-11-20T02:02:14.518Z</updated>
  <id>https://blueanana.github.io/</id>
  
  <author>
    <name><![CDATA[butterfly]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Some About Cycle]]></title>
    <link href="https://blueanana.github.io/2015/11/19/SomeAboutCycle/"/>
    <id>https://blueanana.github.io/2015/11/19/SomeAboutCycle/</id>
    <published>2015-11-19T11:34:29.000Z</published>
    <updated>2015-11-20T02:02:14.518Z</updated>
    <content type="html"><![CDATA[<h1 id="判断环">判断环</h1><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">#141 Linked List Cycle</a></p>
<blockquote>
<p>Given a linked list, determine if it has a cycle in it.<br>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>设两个指向头部的变量one &amp; two，one每次前进一个节点，two另一个每次前进两个。</p>
<ul>
<li>如果链表中存在环，则最后两个变量都会指向同一个节点。<ul>
<li>设两变量都已在环中，两者相距x步。当one继续走x步时，two走了2x步，这时两者重合。</li>
</ul>
</li>
<li>若果链表中没有环，则最后two的指针会走向链尾null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       ListNode one = head, two = head;</span><br><span class="line">       <span class="keyword">while</span> (two.next != <span class="keyword">null</span> &amp;&amp; two.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           one = one.next;</span><br><span class="line">           two = two.next.next;</span><br><span class="line">           <span class="keyword">if</span> (one == two)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h1 id="找出环的起点">找出环的起点</h1><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">#142 Linked List Cycle II</a></p>
<blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.<br>Note: Do not modify the linked list.<br>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>设链表头部节点与环起始节点的距离为<strong>d</strong>，环的长度为<strong>r</strong>。<br>当one变量走了<strong>k</strong>步时，两变量重合(two走了<strong>2k</strong>步，two领先one <strong>n</strong> 圈)，设此时与环起始节点的距离为<strong>s</strong>。</p>
<ul>
<li>2k - k = nr  -&gt;  k = nr</li>
<li>k = d + s + mr  -&gt;  nr = d + s + mr  -&gt;  d + s = (n - m)r<br>从该式可以看出，从s点处再走d步，就能走完整个环，回到环的起点。<br>s点与链表头到环起始节点的距离都是d步。<br>这时让两个变量分别从s点和链表头走，每次走一步，到两者重合的时候，该点就是环的起始节点了。<br><strong>注意要先判断链表中是否有环</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       ListNode one = head, two = head;</span><br><span class="line">       <span class="keyword">while</span> (two.next != <span class="keyword">null</span> &amp;&amp; two.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           one = one.next;</span><br><span class="line">           two = two.next.next;</span><br><span class="line">           <span class="keyword">if</span> (one == two)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (two.next == <span class="keyword">null</span> || two.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line">       one = head;</span><br><span class="line">       <span class="keyword">while</span> (one != two) &#123;</span><br><span class="line">           one = one.next;</span><br><span class="line">           two = two.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> one;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="找出重复的数字">找出重复的数字</h1><p><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="external">#287 Find the Duplicate Number</a></p>
<blockquote>
<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.<br>Note:<br>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p>
</blockquote>
<p>这题的标签有two point和binary search两个，对于这种完全乱序的序列，想不到该怎么应用二分法(事实证明是思考角度完全错了)。</p>
<h2 id="two_point">two point</h2><p>这题的思路是上一题的延伸，可以将数组index与value的对应关系转化为链表(感觉好腻害)。</p>
<blockquote>
<p>0 1 2 3 4 5<br> 2 5 5 1 4 3<br>转换成更直观的形式<br>   ↓<br> 1 2 3 4 5 6<br> 2 5 5 1 4 3</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/mw690/b6e1c277gw1ey77f4ri1fj20f707wjsc.jpg" alt=""></p>
<p>可以看出，重复的数会有至少两个节点指向它，这将形成环(也可能是自己指向自己，这也是环)。然后这就变成了上面的找环的起始节点的问题了。<br>因为数组中的数一定是小于等于n的，所以可以确定没有任何数会指向n，因此可以拿它做头部节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line">       <span class="keyword">int</span> one = len, two = len;</span><br><span class="line">       do &#123;</span><br><span class="line">           one = nums[one-<span class="number">1</span>];</span><br><span class="line">           two = nums[nums[two-<span class="number">1</span>]-<span class="number">1</span>];</span><br><span class="line">       &#125; <span class="keyword">while</span> (one != two);</span><br><span class="line">       one = len;</span><br><span class="line">       <span class="keyword">while</span> (one != two) &#123;</span><br><span class="line">           one = nums[one-<span class="number">1</span>];</span><br><span class="line">           two = nums[two-<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> one;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="binary_search">binary search</h2><p>上面这个做法和二分法并没有半毛钱关系，直到我在讨论区看到了这个 → <a href="https://leetcode.com/discuss/60830/solutions-explanation-space-without-changing-input-array" target="_blank" rel="external">Two Solutions (with explanation): O(nlog(n)) and O(n) time , O(1) space, without changing the input array</a><br>一开始在[1,n]区间中找，得到mid。然后数出数组中所有小于等于mid的数的个数count，若count&gt;mid，说明重复数存在于前半区域中，则下一个搜索区间为[1,mid]，否则为[mid,n]。(耗时)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">1</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">               <span class="keyword">if</span> (nums[i] &lt;= mid)</span><br><span class="line">                   count++;</span><br><span class="line">           <span class="keyword">if</span> (count &gt; mid) right = mid;</span><br><span class="line">           <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>Nice Day ~<br><img src="http://ww2.sinaimg.cn/mw690/b6e1c277gw1ey77gpqrjwj20nz0hstb7.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="判断环">判断环</h1><p><a href="https://leetcode.com/problems/linked-list-cycle/">#141 Linked List Cycle</a></p>
<blockquote>
<p>Given a linked list, determine if it has a cycle in it.<br>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>设两个指向头部的变量one &amp; two，one每次前进一个节点，two另一个每次前进两个。</p>
<ul>
<li>如果链表中存在环，则最后两个变量都会指向同一个节点。<ul>
<li>设两变量都已在环中，两者相距x步。当one继续走x步时，two走了2x步，这时两者重合。</li>
</ul>
</li>
<li>若果链表中没有环，则最后two的指针会走向链尾null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       ListNode one = head, two = head;</span><br><span class="line">       <span class="keyword">while</span> (two.next != <span class="keyword">null</span> &amp;&amp; two.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           one = one.next;</span><br><span class="line">           two = two.next.next;</span><br><span class="line">           <span class="keyword">if</span> (one == two)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="leetcode" scheme="https://blueanana.github.io/tags/leetcode/"/>
    
      <category term="two point" scheme="https://blueanana.github.io/tags/two-point/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Basic Binary Search]]></title>
    <link href="https://blueanana.github.io/2015/11/18/BasicBinarySearch/"/>
    <id>https://blueanana.github.io/2015/11/18/BasicBinarySearch/</id>
    <published>2015-11-18T08:58:04.000Z</published>
    <updated>2015-11-18T13:37:15.938Z</updated>
    <content type="html"><![CDATA[<p>刷了几道二分查找相关的题，稍微总结一下。</p>
<blockquote>
<p><strong>二分查找</strong>是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<br>–wikipedia</p>
</blockquote>
<h1 id="无重复有序数组">无重复有序数组</h1><p>即最基本的二分查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span> <span class="params">(<span class="keyword">int</span>[] nums, target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (target == nums[mid]) retrun mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="微扩展">微扩展</h2><ul>
<li><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="external">#35 Search Insert Position</a></li>
</ul>
<blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
</blockquote>
<p>设想循环走到了后期，即left和right分别指向两个相邻的数。这时会先判断left，如果target<nums[left], 则改变right直到跳出循环；如果target="">nums[left]，则left增一，后面改变的只是right值。<br>总之跳出循环后，left指向总是target所在的位置，或是最近的大于target数(即插入位置)的位置，最后返回left即可(同理，right总是指向target或最近的小于target数)。</nums[left],></p>
<ul>
<li>只需要最后返回值语句改为 <strong>return left;</strong></li>
</ul>
<hr>
<h1 id="有重复有序数组">有重复有序数组</h1><ul>
<li><a href="https://leetcode.com/problems/search-for-a-range/" target="_blank" rel="external">#34 Search for a Range</a></li>
</ul>
<blockquote>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.<br>Your algorithm’s runtime complexity must be in the order of O(log n).<br>If the target is not found in the array, return [-1, -1].</p>
</blockquote>
<p>第一版本：通过二分法找到一个与target相等的数组元素，然后向两边扩展，直到边界。</p>
<p>第二版本：<br>当程序运行到target=nums[mid]的情况时，它可能正处于一串重复的元素之中。这时候可能有两种情况：</p>
<ul>
<li>mid就是边界</li>
<li>边界在mid的左边</li>
</ul>
<p>所以需要做的不是返回，而是继续对左边部分做二分查找，直到最后left与right重合，即为起始边界。或者如果目标值不在数组内，则left为最近的大于target数的位置。(e.g. num[] = {1}, target = 0;)<br>至于结束边界，可以反向思考。<br>看到一个复用代码的方式：找target+1的起始边界，target的结束边界为前者减一。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span> start = getBound(nums, target);</span><br><span class="line">       <span class="comment">//注意判断target不在数组中的情况</span></span><br><span class="line">       <span class="keyword">if</span> (start == nums.length || nums[start] != target)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, getBound(nums, target+<span class="number">1</span>)-<span class="number">1</span>&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">               <span class="keyword">if</span> (left == right)<span class="comment">//mid就是边界</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">else</span>              <span class="comment">//边界在mid左边</span></span><br><span class="line">                   right = mid;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="特殊无序数组">特殊无序数组</h1><p>有一种特殊的无序数组，是一组有序数组在某个点旋转。(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<h2 id="无重复">无重复</h2><ul>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="external">Search in Rotated Sorted Array</a></li>
</ul>
<blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.<br>You are given a target value to search. If found in the array return its index, otherwise return -1.<br>You may assume no duplicate exists in the array.</p>
</blockquote>
<p>第一版本：先通过二分查找找到分界pivot，然后判断target处于前半部分还是后半部分，最后对相应部分做二分查找。<br>第二版本：做正常二分查找，并在查找途中进行相应判断。得到mid后，判断left与mid位置值的大小。</p>
<ul>
<li>nums[left] &lt;= nums[mid]，说明左半边是正常序列，即没有pivot。<ul>
<li>判断target是否在左半边序列范围内，若在，则继续对左半边进行查找；(注意范围的定义)</li>
<li>若不在，则查找右半边。</li>
</ul>
</li>
<li>nums[left] &gt; nums[mid]，pivot在左半边。原理与上面相同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                   right = mid-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   left = mid+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                   left = mid+<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   right = mid-<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="有重复">有重复</h2><ul>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="external">Search in Rotated Sorted Array II</a></li>
</ul>
<blockquote>
<p>Follow up for “Search in Rotated Sorted Array”:<br>What if duplicates are allowed?<br>Write a function to determine if a given target is in the array.</p>
</blockquote>
<p>相比较于无重数组，多了一种特殊情况：e.g. 1111112 -&gt; 1121111 -&gt; 1111211<br>你无法判断pivot在左还是右，甚至是否存在。<br>这时nums[left] == nums[mid]就无法二分了，因为根本不知道往哪个区间二分，这时候只能遍历，直到left遇到一个其他数字，或超出范围。<br>最坏情况：全部都是同一个数的重复数组，O(n)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                   right = mid-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   left = mid+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                   left = mid+<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   right = mid-<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               left++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结">总结</h1><p>觉得最重要还是要理清最后left和right指向的到底是什么吧，总是想着想着就乱掉。</p>
<ul>
<li>最后left和right指向两个相邻的数</li>
<li>先判断left，然后是right</li>
<li>right指向的是小于等于target的数</li>
<li>left指向的是大于等于target的数</li>
</ul>
<p>发现有几道应用二分查找的无序数组的题，需要再探索一下。<br>Continue…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>刷了几道二分查找相关的题，稍微总结一下。</p>
<blockquote>
<p><strong>二分查找</strong>是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<br>–wikipedia</p>
</blockquote>
<h1 id="无重复有序数组">无重复有序数组</h1><p>即最基本的二分查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span> <span class="params">(<span class="keyword">int</span>[] nums, target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (target == nums[mid]) retrun mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="binary search" scheme="https://blueanana.github.io/tags/binary-search/"/>
    
      <category term="leetcode" scheme="https://blueanana.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown Grammar]]></title>
    <link href="https://blueanana.github.io/2015/11/17/markdown/"/>
    <id>https://blueanana.github.io/2015/11/17/markdown/</id>
    <published>2015-11-17T04:14:11.000Z</published>
    <updated>2015-11-17T04:31:10.206Z</updated>
    <content type="html"><![CDATA[<h2 id="1-Title">1.Title</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># Title <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">## Title <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">### Title <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#### Title <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">##### Title <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">###### Title <span class="number">6</span></span></span><br><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>
<h1 id="Title_1">Title 1</h1><h2 id="Title_2">Title 2</h2><h3 id="Title_3">Title 3</h3><h4 id="Title_4">Title 4</h4><h5 id="Title_5">Title 5</h5><h6 id="Title_6">Title 6</h6><hr>
<a id="more"></a>
<h2 id="2-_Reference">2. Reference</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="operator">Reference</span></span><br><span class="line">&gt;&gt; Nesting <span class="operator">Reference</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Reference</p>
<blockquote>
<p>Nesting Reference</p>
</blockquote>
</blockquote>
<hr>
<h2 id="3-_Font">3. Font</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span>Italics<span class="keyword">*</span></span><br><span class="line">_Italics_</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>Bold face<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">__Bold face__</span><br><span class="line">~~delete~~</span><br></pre></td></tr></table></figure>
<p><em>Italics</em><br><em>Italics</em><br><strong>Bold face</strong><br><strong>Bold face</strong><br><del>delete</del></p>
<hr>
<h2 id="4-_List">4. List</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>list1</span><br><span class="line">  - nest list1</span><br><span class="line"><span class="code">    - nest nest list</span></span><br><span class="line">  + nest list2</span><br><span class="line">  * nest list3</span><br><span class="line"><span class="bullet">+ </span>list2</span><br><span class="line"><span class="bullet">* </span>list3</span><br><span class="line"><span class="bullet">1. </span>list1</span><br><span class="line"><span class="bullet">1. </span>list2</span><br><span class="line"><span class="bullet">2. </span>list3</span><br></pre></td></tr></table></figure>
<ul>
<li>list1<ul>
<li>nest list1<ul>
<li>nest nest list</li>
</ul>
</li>
</ul>
<ul>
<li>nest list2</li>
</ul>
<ul>
<li>nest list3</li>
</ul>
</li>
</ul>
<ul>
<li>list2</li>
</ul>
<ul>
<li>list3</li>
</ul>
<ol>
<li>list1</li>
<li>list2</li>
<li>list3</li>
</ol>
<hr>
<h2 id="5-_Link">5. Link</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="link_label">Google</span>](<span class="link_url">http://google.com</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">http:</span>//<span class="attribute">google.com</span>&gt;</span></span></span><br><span class="line">![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_5BgORGNs3DOYv3eN3oF8mHUpbMrahuwdZV4KedxXCsoHxrh9cQ)</span><br><span class="line"></span><br><span class="line">reference link:</span><br><span class="line">[<span class="link_label">Google</span>][<span class="link_reference">1</span>]</span><br><span class="line">![][2]</span><br><span class="line">[<span class="link_reference">1</span>]:<span class="link_url"> http://google.com</span></span><br><span class="line">[<span class="link_reference">2</span>]:<span class="link_url"> https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_5BgORGNs3DOYv3eN3oF8mHUpbMrahuwdZV4KedxXCsoHxrh9cQ</span></span><br></pre></td></tr></table></figure>
<p><a href="http://google.com" target="_blank" rel="external">Google</a><br><a href="http://google.com" target="_blank" rel="external">http://google.com</a><br><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_5BgORGNs3DOYv3eN3oF8mHUpbMrahuwdZV4KedxXCsoHxrh9cQ" alt=""></p>
<hr>
<h2 id="6-_code">6. code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-_form">7. form</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">first</span>|<span class="string">second</span>|<span class="string">third</span>|</span><br><span class="line">|<span class="string">--</span>|<span class="string">:--:</span>|<span class="string">--:</span>|</span><br><span class="line">|<span class="string">1</span>|<span class="string">2</span>|<span class="string">3</span>|</span><br><span class="line">|<span class="string">1</span>|<span class="string">2</span>|<span class="string">3</span>|</span><br><span class="line"><span class="variable">&lt;!-- don't you think the blank is form is useless... !--&gt;</span></span><br><span class="line"><span class="variable">&lt;!-- this form is also ok ↓ --!&gt;</span></span><br><span class="line"></span><br><span class="line">first|<span class="string">second</span>|third</span><br><span class="line">--|<span class="string">:--:</span>|<span class="string">--:</span><br><span class="line">1</span>|<span class="string">2</span>|3</span><br><span class="line">1|<span class="string">2</span>|3</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>first</th>
<th style="text-align:center">second</th>
<th style="text-align:right">third</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">2</td>
<td style="text-align:right">3</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">2</td>
<td style="text-align:right">3</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-Title">1.Title</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># Title <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">## Title <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">### Title <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#### Title <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">##### Title <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">###### Title <span class="number">6</span></span></span><br><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>
<h1 id="Title_1">Title 1</h1><h2 id="Title_2">Title 2</h2><h3 id="Title_3">Title 3</h3><h4 id="Title_4">Title 4</h4><h5 id="Title_5">Title 5</h5><h6 id="Title_6">Title 6</h6><hr>]]>
    
    </summary>
    
      <category term="markdown" scheme="https://blueanana.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
