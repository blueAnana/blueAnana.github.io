<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Pineapple]]></title>
  <subtitle><![CDATA[Record Something]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="https://blueanana.github.io/"/>
  <updated>2015-11-24T12:45:19.581Z</updated>
  <id>https://blueanana.github.io/</id>
  
  <author>
    <name><![CDATA[butterfly]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[StringIII]]></title>
    <link href="https://blueanana.github.io/2015/11/24/StringIII/"/>
    <id>https://blueanana.github.io/2015/11/24/StringIII/</id>
    <published>2015-11-24T11:24:45.000Z</published>
    <updated>2015-11-24T12:45:19.581Z</updated>
    <content type="html"><![CDATA[<ul>
<li>Reverse Words in a String</li>
<li>Longest Common SubSequence</li>
</ul>
<h1 id="Reverse_Words_in_a_String">Reverse Words in a String</h1><p><a href="https://leetcode.com/problems/reverse-words-in-a-string/" target="_blank" rel="external">Reverse Words in a String</a></p>
<blockquote>
<p>Given an input string, reverse the string word by word.<br>For example,<br>Given s = “the sky is blue”,<br>return “blue is sky the”.</p>
</blockquote>
<p>之前有遇到这个题目，现在看到别人家的simple solution之后，发现用暴力解题的我真是太low了。<br>利用正则表达式，直接调用String类自带的工具–split()方法。</p>
<blockquote>
<p>split() – “将字符串从正则表达式匹配的地方切开。”<br>–《Thinking in Java》</p>
</blockquote>
<p>在这题中，就可以使用该方法，将String字符串从根据空格切割成String数组，每个元素就是一个单词(貌似不用考虑标点？)。<br>最后倒序输出就可以了。<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       String[] word = s.split(<span class="string">"\\s+"</span>);</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = word.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">           sb.append(word[i]).append(<span class="string">" "</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>题外话<br>当输入为” “时</p>
<ul>
<li>s.trim().split();</li>
<li>s.split();</li>
</ul>
<p>这两句产生的结果是不一样的。<br>输入返回的数组的长度，前者的长度为1，而后者的长度为0。<br>trim()方法的作用是取出首尾空格。当它被执行于” “时，得到一个空字符串，这时split()是没有进行切割的，所以最后得到一个含有空串的数组。<br>没有trim()时，split()对它进行切割(我理解为把空格给剔除了)，这时因为空格前后是没有字符的，所以最后得到一个空数组。<br>特殊情况还是要多想想啊~</p>
<hr>
<h1 id="最长公共子序列">最长公共子序列</h1><p>看到WPA题库里会有这题，就刷了一下。</p>
<blockquote>
<p>一个数列S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则S称为已知序列的最长公共子序列。<br>– wiki</p>
</blockquote>
<p>最长公共子序列(Longest Common SubSequence)和最长公共子串(Longest Common SubString)是不一样的，前者不要求连续。<br>比如：</p>
<ul>
<li>abcde</li>
<li><strong>a</strong>kk<strong>bc</strong>kk<br>abc即是它们的公共子串。</li>
</ul>
<p>如果用暴力破解的话，时间复杂度到了指数级的高度。一般是用动规来解决(貌似是动规经典题？)。</p>
<h2 id="公共子序列长度">公共子序列长度</h2><p>首先是先考虑得到最长公共子序列的长度。<br>利用动规的思想，将问题分割为子问题，然后在子问题的解上判断。<br>对于字符串a和b，记录下a前i个和b前j个的子串所拥有的最长公共子序列，然后在子串的基础上判断之后字符串。</p>
<ul>
<li>若a[i] == b[j]，说明a[i]也是公共子序列的元素之一，就可以在长度a[i-1]和b[j-1]的子串所记录的lcs长度上加一。</li>
<li>若a[i] != b[j]，则要在(a[i-1]&amp;b[j])和(a[i]&amp;b[j-1])两种情况下取较大值做自己的最长公共子序列长度。<br>设一个二维数组dp来记录前i位a和前j位b的最长公共子序列长度。<br>然后可以归纳为：</li>
<li>i = 0 || j = 0 – dp[i][j] = 0;</li>
<li>a[i] == b[j]   – dp[i][j] = dp[i-1][j-1];</li>
<li>a[i] != b[j]   – dp[i][j] = max(dp[i-1][j], dp[i][j-1])<br>最后，dp[m]<a href="mn分别是ab的长度">n</a>即是ab字符串的最长公共子序列的长度了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lcs</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lenA = a.length(), lenB = b.length();</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lenA+<span class="number">1</span>][lenB+<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenB; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a.charAt(i-<span class="number">1</span>) == b.charAt(j-<span class="number">1</span>))</span><br><span class="line">				dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(dp[lenA][lenB]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输出最长公共子序列">输出最长公共子序列</h2><p>如果要输出最长公共子序列，那就需要知道得到该子序列的路径，即dp[i][j]是从dp的哪个位置的得到的。<br>所以在记录dp时，我们可以另设一个二维数组记录方向，因为每次都只会来自左，上，及左上方，所以要记录这三个方向。</p>
<ul>
<li>来自dp[i-1][j-1]， director[i][j] = “left_up”;</li>
<li>来自dp[i-1][j],    director[i][j] = “up”;</li>
<li>来自dp[i][j-1],    director[i][j] = “left”;<br>然后再根据director所指的方向(从右下角开始走)，找到对应的字符就可以了(注意这时是倒序)。<blockquote>
<p>0 0 0 0 0 0 0<br><strong>0</strong> 0 0 0 1 1 1<br>0 <strong>1</strong> <strong>1</strong> 1 1 2 2<br>0 1 1 <strong>2</strong> <strong>2</strong> 2 2<br>0 1 1 2 2 <strong>3</strong> 3<br>0 1 2 2 2 <strong>3</strong> 3<br>0 1 2 2 3 3 <strong>4</strong><br>0 1 2 2 3 4 <strong>4</strong></p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lcs</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lenA = a.length(), lenB = b.length();</span><br><span class="line">	<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[lenA+<span class="number">1</span>][lenB+<span class="number">1</span>];</span><br><span class="line">	String[][] director = <span class="keyword">new</span> String[lenA+<span class="number">1</span>][lenB+<span class="number">1</span>]; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lenA; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lenB; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (a.charAt(i-<span class="number">1</span>) == b.charAt(j-<span class="number">1</span>)) &#123;</span><br><span class="line">				dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">				director[i][j] = <span class="string">"left_up"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  &#123;</span><br><span class="line">				<span class="keyword">if</span> (dp[i-<span class="number">1</span>][j] &gt;= dp[i][j-<span class="number">1</span>]) &#123;</span><br><span class="line">					dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">					director[i][j] = <span class="string">"up"</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					dp[i][j] = dp[i][j-<span class="number">1</span>];</span><br><span class="line">					director[i][j] = <span class="string">"left"</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printSubsequence(director, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printSubsequence</span><span class="params">(String[][] director, String a, String b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lenA = a.length(), lenB = b.length();</span><br><span class="line">	StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	<span class="keyword">while</span> (lenA != <span class="number">0</span> &amp;&amp; lenB != <span class="number">0</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (director[lenA][lenB].equals(<span class="string">"left_up"</span>))  &#123;</span><br><span class="line">			sb.append(a.charAt(lenA-<span class="number">1</span>));</span><br><span class="line">			lenA--;</span><br><span class="line">			lenB--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (director[lenA][lenB].equals(<span class="string">"left"</span>)) &#123;</span><br><span class="line">			lenB--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			lenA--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(sb.reverse().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li>Reverse Words in a String</li>
<li>Longest Common SubSequence</li>
</ul>
<h1 id="Reverse_Words_in_a_String">Reverse Words in a String</h1><p><a href="https://leetcode.com/problems/reverse-words-in-a-string/">Reverse Words in a String</a></p>
<blockquote>
<p>Given an input string, reverse the string word by word.<br>For example,<br>Given s = “the sky is blue”,<br>return “blue is sky the”.</p>
</blockquote>
<p>之前有遇到这个题目，现在看到别人家的simple solution之后，发现用暴力解题的我真是太low了。<br>利用正则表达式，直接调用String类自带的工具–split()方法。</p>
<blockquote>
<p>split() – “将字符串从正则表达式匹配的地方切开。”<br>–《Thinking in Java》</p>
</blockquote>
<p>在这题中，就可以使用该方法，将String字符串从根据空格切割成String数组，每个元素就是一个单词(貌似不用考虑标点？)。<br>最后倒序输出就可以了。<br>]]>
    
    </summary>
    
      <category term="string" scheme="https://blueanana.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[String II]]></title>
    <link href="https://blueanana.github.io/2015/11/23/StringII/"/>
    <id>https://blueanana.github.io/2015/11/23/StringII/</id>
    <published>2015-11-23T13:15:12.000Z</published>
    <updated>2015-11-23T13:44:24.805Z</updated>
    <content type="html"><![CDATA[<h1 id="括号匹配">括号匹配</h1><p><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="external">#20 Valid Parentheses</a></p>
<blockquote>
<p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p>
</blockquote>
<p>借用栈来实现。若是合法的括号，左右括号必然是对称的。遍历字符串，遇到左括号即压入栈内；遇到右括号则与栈顶元素匹配，若匹配则弹出，否则返回false。<br>需要注意到一些特殊情况，比如：”(“ “)”这样的。若到了最后，栈中仍有括号，说明不合法；在弹栈前要确认栈内不为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">               stack.push(c);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">char</span> pre = stack.pop();</span><br><span class="line">               <span class="keyword">if</span> ((c == <span class="string">')'</span> &amp;&amp; pre == <span class="string">'('</span>) || (c == <span class="string">']'</span> &amp;&amp; pre == <span class="string">'['</span>) || (c == <span class="string">'&#125;'</span> || pre == <span class="string">'&#123;'</span>))</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="最长无重复字符串匹配">最长无重复字符串匹配</h1><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="external">#3 Longest Substring Without Repeating Characters</a></p>
<blockquote>
<p>Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for “abcabcbb” is “abc”, which the length is 3. For “bbbbb” the longest substring is “b”, with the length of 1.</p>
</blockquote>
<p>用两个变量来圈定当前正在判断的无重复字符串。<br>设一个hash表，来记录各字符上一次出现的位置。在遍历字符串时，查询当前字符在表中的值。<br>若该字符上一次出现的位置在圈定范围内，说明出现了重复字符，将left重定向到前面重复字符的下一个位置。更新hash表，然后继续向下判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, max = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash.length; i++)</span><br><span class="line">           hash[i] = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (hash[s.charAt(i)] &gt;= left) &#123;</span><br><span class="line">               max = Math.max(max, i - left);</span><br><span class="line">               left = hash[s.charAt(i)] + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           hash[s.charAt(i)] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> Math.max(max, s.length() - left);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="是否是合法回文">是否是合法回文</h1><p><a href="https://leetcode.com/problems/valid-palindrome/" target="_blank" rel="external">#125 Valid Palindrome</a></p>
<blockquote>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.<br>For example,<br>“A man, a plan, a canal: Panama” is a palindrome.<br>“race a car” is not a palindrome.<br>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.<br>For the purpose of this problem, we define empty string as valid palindrome.</p>
</blockquote>
<p>设两个变量分别指向头尾，然后逐渐匹配向中间靠拢。<br>注意数字也要判断，忽略空格和字符。<br>原来我对字符的判断是这样写的：(s.charAt(right) &lt; ‘0’ || (s.charAt(right) &gt; ‘9’ &amp;&amp; s.charAt(right) &lt; ‘a’) || s.charAt(right) &gt; ‘z’)<br>后来发现Character类自带字母与数字判断函数：Character.isLetterOrDigit(c);<br>看来还是要把库函数记熟才好啊~什么时候整理一下~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length()-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(left)))</span><br><span class="line">               left++;</span><br><span class="line">           <span class="keyword">while</span> (left &lt; right &amp;&amp; !Character.isLetterOrDigit(s.charAt(right)))</span><br><span class="line">               right--;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           left++;</span><br><span class="line">           right--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>今天收集了网上WAP面经里提到的题目，明天开刷 ~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="括号匹配">括号匹配</h1><p><a href="https://leetcode.com/problems/valid-parentheses/">#20 Valid Parentheses</a></p>
<blockquote>
<p>Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.</p>
</blockquote>
<p>借用栈来实现。若是合法的括号，左右括号必然是对称的。遍历字符串，遇到左括号即压入栈内；遇到右括号则与栈顶元素匹配，若匹配则弹出，否则返回false。<br>需要注意到一些特殊情况，比如：”(“ “)”这样的。若到了最后，栈中仍有括号，说明不合法；在弹栈前要确认栈内不为空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="string">'('</span> || c == <span class="string">'['</span> || c == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">               stack.push(c);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (stack.isEmpty())</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">char</span> pre = stack.pop();</span><br><span class="line">               <span class="keyword">if</span> ((c == <span class="string">')'</span> &amp;&amp; pre == <span class="string">'('</span>) || (c == <span class="string">']'</span> &amp;&amp; pre == <span class="string">'['</span>) || (c == <span class="string">'&#125;'</span> || pre == <span class="string">'&#123;'</span>))</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="leetcode" scheme="https://blueanana.github.io/tags/leetcode/"/>
    
      <category term="string" scheme="https://blueanana.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[N-Queen]]></title>
    <link href="https://blueanana.github.io/2015/11/23/NQueen/"/>
    <id>https://blueanana.github.io/2015/11/23/NQueen/</id>
    <published>2015-11-23T13:14:51.000Z</published>
    <updated>2015-11-24T12:36:38.585Z</updated>
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/n-queens/" target="_blank" rel="external">#51 N-Queens</a></p>
<blockquote>
<p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</p>
</blockquote>
<p><img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png" alt=""></p>
<blockquote>
<p>Given an integer n, return all distinct solutions to the n-queens puzzle.<br>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.<br>For example,<br>There exist two distinct solutions to the 4-queens puzzle:</p>
</blockquote>
<pre><code>[
 [<span class="string">".Q.."</span>,  // Solution <span class="number">1</span>
   <span class="string">"...Q"</span>,
  <span class="string">"Q..."</span>,
  <span class="string">"..Q."</span>],

 [<span class="string">"..Q."</span>,  // Solution <span class="number">2</span>
   <span class="string">"Q..."</span>,
  <span class="string">"...Q"</span>,
  <span class="string">".Q.."</span>]
]
</code></pre><p>感觉题目说的不清不楚的，至少我看完上面的题目描述，我不知道我应该做什么。<br>将n个皇后棋子布置在一个n*n的棋盘上，使两个皇后之间无法互相攻击，及每一行，每一列，每一斜线上都只有唯一一个棋子存在(注意有两条斜线)。<br>以行作为回溯单位<br><a id="more"></a><br>//to do</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">       <span class="keyword">boolean</span>[][] board = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">       List&lt;List&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">3</span>)</span><br><span class="line">           <span class="keyword">return</span> list;</span><br><span class="line">       setQueen(<span class="number">0</span>, <span class="number">0</span>, board, n, list);</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setQueen</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">boolean</span>[][] board, <span class="keyword">int</span> n, List&lt;List&lt;String&gt;&gt; list)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (row &lt; n &amp;&amp; col &lt; n) &#123;</span><br><span class="line">           <span class="keyword">if</span> (check(row, col, board, n)) &#123;</span><br><span class="line">               board[row][col] = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">//最后一行时，将目前方案放入list</span></span><br><span class="line">               <span class="keyword">if</span> (row == n -<span class="number">1</span>) &#123;</span><br><span class="line">                   List&lt;String&gt; oneRes = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (board[i][j])</span><br><span class="line">                               sb.append(<span class="string">"Q"</span>);</span><br><span class="line">                           <span class="keyword">else</span></span><br><span class="line">                               sb.append(<span class="string">"."</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                       oneRes.add(sb.toString());</span><br><span class="line">                   &#125;</span><br><span class="line">                   list.add(oneRes);</span><br><span class="line">                   board[row][col] = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               setQueen(row+<span class="number">1</span>, <span class="number">0</span>, board, n, list);</span><br><span class="line">               board[row][col] = <span class="keyword">false</span>;</span><br><span class="line">               col++;</span><br><span class="line">    </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (col &lt; n-<span class="number">1</span>)</span><br><span class="line">                   col++;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">boolean</span>[][] board, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//同列有无皇后</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (board[i][col] == <span class="keyword">true</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//同行有无皇后</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (board[row][i] == <span class="keyword">true</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//往左上方向</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">           <span class="keyword">if</span> (board[i][j] == <span class="keyword">true</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//往右上方向</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (board[i][j] == <span class="keyword">true</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://leetcode.com/problems/n-queens/">#51 N-Queens</a></p>
<blockquote>
<p>The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</p>
</blockquote>
<p><img src="http://www.leetcode.com/wp-content/uploads/2012/03/8-queens.png" alt=""></p>
<blockquote>
<p>Given an integer n, return all distinct solutions to the n-queens puzzle.<br>Each solution contains a distinct board configuration of the n-queens’ placement, where ‘Q’ and ‘.’ both indicate a queen and an empty space respectively.<br>For example,<br>There exist two distinct solutions to the 4-queens puzzle:</p>
</blockquote>
<pre><code>[
 [<span class="string">".Q.."</span>,  // Solution <span class="number">1</span>
   <span class="string">"...Q"</span>,
  <span class="string">"Q..."</span>,
  <span class="string">"..Q."</span>],

 [<span class="string">"..Q."</span>,  // Solution <span class="number">2</span>
   <span class="string">"Q..."</span>,
  <span class="string">"...Q"</span>,
  <span class="string">".Q.."</span>]
]
</code></pre><p>感觉题目说的不清不楚的，至少我看完上面的题目描述，我不知道我应该做什么。<br>将n个皇后棋子布置在一个n*n的棋盘上，使两个皇后之间无法互相攻击，及每一行，每一列，每一斜线上都只有唯一一个棋子存在(注意有两条斜线)。<br>以行作为回溯单位<br>]]>
    
    </summary>
    
      <category term="backtracking" scheme="https://blueanana.github.io/tags/backtracking/"/>
    
      <category term="leetcode" scheme="https://blueanana.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[String I]]></title>
    <link href="https://blueanana.github.io/2015/11/21/StringI/"/>
    <id>https://blueanana.github.io/2015/11/21/StringI/</id>
    <published>2015-11-21T09:37:40.000Z</published>
    <updated>2015-11-21T14:54:21.641Z</updated>
    <content type="html"><![CDATA[<h1 id="Group_Anagrams">Group Anagrams</h1><p><a href="https://leetcode.com/problems/anagrams/" target="_blank" rel="external">#49 Group Anagrams</a></p>
<blockquote>
<p>Given an array of strings, group anagrams together.<br>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:<br>[<br>  [“ate”, “eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>Note:<br>For the return value, each inner list’s elements must follow the lexicographic order.<br>All inputs will be in lower-case.</p>
</blockquote>
<p>思路：先将各个单词排序，排序后的字符串相同的单词即是anagrams。<br>具体实现需要用到容器HashMap<sorted, original="" list="">，以键值对的形式保存排序后字符串相同的所有单词。key就是排序后字符串，value就是原本的单词组成的list。<br>e.g. (“abc”, [“abc”, “acb”, “bac”])</sorted,></p>
<ul>
<li>遍历string数组，得到当前单词的顺序字符串，然后在HashMap中查找。</li>
<li>若HashMap中已存在该key，则将该单词插入到对应的list中。</li>
<li>若不存在，则新插入键值对。<br>最后将Map中的list放入需要返回的表中。<br>注意，因为题中要求list中的元素是有序的，所以要在最开始的时候将单词数组排序，以保证插入的顺序。<a id="more"></a>
对容器的使用还不是很熟练啊~而且没有IDE，库函数好难记啊~</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">       <span class="comment">//排序不能少，因为要保证最后结果是顺序的</span></span><br><span class="line">       Arrays.sort(strs);</span><br><span class="line">       Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">           <span class="keyword">char</span>[] c = strs[i].toCharArray();</span><br><span class="line">           Arrays.sort(c);</span><br><span class="line">           String s = String.valueOf(c);</span><br><span class="line">           <span class="keyword">if</span> (!map.containsKey(s)) </span><br><span class="line">               map.put(s, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">           map.get(s).add(strs[i]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Interleaving_String">Interleaving String</h1><p><a href="https://leetcode.com/problems/interleaving-string/" target="_blank" rel="external">#97 Interleaving String</a></p>
<blockquote>
<p>Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.<br>For example,<br>Given:<br>s1 = “aabcc”,<br>s2 = “dbbca”,<br>When s3 = “aadbbcbcac”, return true.<br>When s3 = “aadbbbaccc”, return false.</p>
</blockquote>
<p>要用到’dynamic programing’的思想。<br>若s1的前i个与s2的前j个对于s3的前(i+j)个来说是合法的(即这部分的s1和s2可以插入得到s3)，则可继续对s3的(i+j+1)个进行判断。</p>
<ul>
<li>最开始初始化i=0和j=0的情况为合法。</li>
<li>i=0即s1为空，只判断s2。</li>
<li>j=0即s2为空，只判断s1。</li>
<li>都不为空，则s1或s2有一个合法即可。</li>
<li>最后返回s1s2都插入后的结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line">       <span class="keyword">if</span> (s3.length() != len1 + len2)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)</span><br><span class="line">                   dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                   dp[i][j] = dp[i][j-<span class="number">1</span>] &amp;&amp; s2.charAt(j-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>);</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                   dp[i][j] = dp[i-<span class="number">1</span>][j] &amp;&amp; s1.charAt(i-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   dp[i][j] = (dp[i-<span class="number">1</span>][j] &amp;&amp; s1.charAt(i-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>)) || (dp[i][j-<span class="number">1</span>] &amp;&amp; s2.charAt(j-<span class="number">1</span>) == s3.charAt(i+j-<span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Integer_to_English_Words">Integer to English Words</h1><p><a href="https://leetcode.com/problems/integer-to-english-words/" target="_blank" rel="external">#273 Integer to English Words</a></p>
<blockquote>
<p>Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 231 - 1.<br>For example,<br>123 -&gt; “One Hundred Twenty Three”<br>12345 -&gt; “Twelve Thousand Three Hundred Forty Five”<br>1234567 -&gt; “One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven”</p>
</blockquote>
<p>大致分为(以前没注意，现在才发现歪果仁写数字总三个数隔一个逗号的用意。)：</p>
<pre><code><span class="string">"123"</span> -&gt; <span class="string">"One Hundred Twenty Three"</span>
<span class="string">"123,000"</span> -&gt; <span class="string">"One Hundred Twenty Three Thousand"</span>
<span class="string">"123,000,000"</span> -&gt; <span class="string">"One Hundred Twenty Three Million"</span>
<span class="string">"123,000,000,000"</span> -&gt; <span class="string">"One Hundred Twenty Three Billion"</span>
</code></pre><p>可以每三个数字转换，然后相应加上Thousand, Million, Billion。<br>注意要考虑一些特殊情况，比如’0’和’1000中的0’，’11’和’21’等。<br>考虑空格真是太麻烦了！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String[] digit = <span class="keyword">new</span> String[] &#123;<span class="string">""</span>, <span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>, <span class="string">"Four"</span>, <span class="string">"Five"</span>, <span class="string">"Six"</span>, <span class="string">"Seven"</span>, <span class="string">"Eight"</span>, <span class="string">"Nine"</span>, <span class="string">"Ten"</span>, <span class="string">"Eleven"</span>, <span class="string">"Twelve"</span>, <span class="string">"Thirteen"</span>, <span class="string">"Fourteen"</span>, <span class="string">"Fifteen"</span>, <span class="string">"Sixteen"</span>, <span class="string">"Seventeen"</span>, <span class="string">"Eighteen"</span>, <span class="string">"Nineteen"</span>&#125;;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String[] tens = <span class="keyword">new</span> String[] &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"Twenty"</span>, <span class="string">"Thirty"</span>, <span class="string">"Forty"</span>, <span class="string">"Fifty"</span>, <span class="string">"Sixty"</span>, <span class="string">"Seventy"</span>, <span class="string">"Eighty"</span>, <span class="string">"Ninety"</span>, <span class="string">"Hundred"</span>&#125;;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String[] more = <span class="keyword">new</span> String[] &#123;<span class="string">""</span>, <span class="string">" Thousand"</span>, <span class="string">" Million"</span>, <span class="string">" Billion"</span>&#125;; </span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">numberToWords</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> digit[num];</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           String temp = sb.toString();</span><br><span class="line">           <span class="keyword">if</span> (num % <span class="number">1000</span> != <span class="number">0</span>) &#123;</span><br><span class="line">               StringBuilder t = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">               t.append(inThreeDigit(num % <span class="number">1000</span>)).append(more[flag]);</span><br><span class="line">               <span class="keyword">if</span> (!temp.equals(<span class="string">""</span>))</span><br><span class="line">                   t.append(<span class="string">" "</span>).append(temp);</span><br><span class="line">               sb = t;</span><br><span class="line">           &#125;</span><br><span class="line">           num = num / <span class="number">1000</span>;</span><br><span class="line">           flag++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">inThreeDigit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">       StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">       <span class="keyword">if</span> (num &lt; <span class="number">20</span>)</span><br><span class="line">           sb.append(digit[num]);</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">100</span>) &#123;</span><br><span class="line">           sb.append(tens[num/<span class="number">10</span>]);</span><br><span class="line">           <span class="keyword">if</span> (num % <span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">               sb.append(<span class="string">" "</span>).append(digit[num%<span class="number">10</span>]);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>  &#123;</span><br><span class="line">           sb.append(digit[num/<span class="number">100</span>]).append(<span class="string">" Hundred"</span>);</span><br><span class="line">           num %= <span class="number">100</span>;</span><br><span class="line">           <span class="keyword">if</span> (num &lt; <span class="number">20</span> &amp;&amp; num != <span class="number">0</span>)</span><br><span class="line">               sb.append(<span class="string">" "</span>).append(digit[num]);</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">               sb.append(<span class="string">" "</span>).append(tens[num/<span class="number">10</span>]);</span><br><span class="line">               <span class="keyword">if</span> (num % <span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">                   sb.append(<span class="string">" "</span>).append(digit[num%<span class="number">10</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>吐槽：感觉关于字符串处理，很多是考的归纳能力，然后就着wrong answer打补丁。<br>这两天刷的有点乱，希望明天能有条理一点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Group_Anagrams">Group Anagrams</h1><p><a href="https://leetcode.com/problems/anagrams/">#49 Group Anagrams</a></p>
<blockquote>
<p>Given an array of strings, group anagrams together.<br>For example, given: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”],<br>Return:<br>[<br>  [“ate”, “eat”,”tea”],<br>  [“nat”,”tan”],<br>  [“bat”]<br>]<br>Note:<br>For the return value, each inner list’s elements must follow the lexicographic order.<br>All inputs will be in lower-case.</p>
</blockquote>
<p>思路：先将各个单词排序，排序后的字符串相同的单词即是anagrams。<br>具体实现需要用到容器HashMap<sorted, original list>，以键值对的形式保存排序后字符串相同的所有单词。key就是排序后字符串，value就是原本的单词组成的list。<br>e.g. (“abc”, [“abc”, “acb”, “bac”])</p>
<ul>
<li>遍历string数组，得到当前单词的顺序字符串，然后在HashMap中查找。</li>
<li>若HashMap中已存在该key，则将该单词插入到对应的list中。</li>
<li>若不存在，则新插入键值对。<br>最后将Map中的list放入需要返回的表中。<br>注意，因为题中要求list中的元素是有序的，所以要在最开始的时候将单词数组排序，以保证插入的顺序。]]>
    
    </summary>
    
      <category term="dynamic programing" scheme="https://blueanana.github.io/tags/dynamic-programing/"/>
    
      <category term="leetcode" scheme="https://blueanana.github.io/tags/leetcode/"/>
    
      <category term="string" scheme="https://blueanana.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对某题的吐槽]]></title>
    <link href="https://blueanana.github.io/2015/11/20/TuCao/"/>
    <id>https://blueanana.github.io/2015/11/20/TuCao/</id>
    <published>2015-11-20T10:19:48.000Z</published>
    <updated>2015-11-20T11:01:18.944Z</updated>
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="external">#65 Valid Number</a></p>
<blockquote>
<p>Validate if a given string is numeric.<br>Some examples:<br>“0” =&gt; true<br>“ 0.1 “ =&gt; true<br>“abc” =&gt; false<br>“1 a” =&gt; false<br>“2e10” =&gt; true<br>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p>
</blockquote>
<p>第一次看到这道题的时候我的表情是这样的 → <img src="http://ww3.sinaimg.cn/mw690/b6e1c277gw1ey7md39mykj202h030glh.jpg" alt=""><br>主要考的应该是归纳能力吧，虽然好像有很多情况的样子，但好好列出来应该也是没问题的吧？<br>too simple too naive<br><a id="more"></a></p>
<p>我的第一个版本：</p>
<ol>
<li>去除首尾空格</li>
<li>判断第一个字符<ol>
<li>0</li>
</ol>
<ul>
<li>下一个如果不是小数点或结束 – false</li>
</ul>
<ol>
<li>其他数字</li>
<li>其他字符 – false</li>
</ol>
</li>
<li>剩余字符<ol>
<li>数字</li>
<li>小数点</li>
</ol>
<ul>
<li>重复出现 – false</li>
<li>下一个结束 – false</li>
</ul>
<ol>
<li>科学计数法e</li>
</ol>
<ul>
<li>重复出现 – false</li>
<li>后面跟0 –false</li>
<li>下一个结束 – false</li>
</ul>
<ol>
<li>其他字符 – false</li>
</ol>
</li>
</ol>
<p>大致是这些吧，可能有些情况没考虑到，运行一下看看结果，再加上就好了嘛。<br>然后我得到了这个结果：<br>“01” -&gt; true<br><img src="http://ww3.sinaimg.cn/small/b6e1c277gw1ey7m2f7yd2j201o01ojr5.jpg" alt=""><br>这玩意居然是合法数字？<br>好咯，你给ACC你说了算咯，改呗。</p>
<p>然后我遇到了接下来一系列结果：<br>“.1” -&gt; true<br>“3.” -&gt; true<br>“2e0” -&gt; true<br>…<br>简直颠覆了我对数字的理解<br><img src="http://ww2.sinaimg.cn/small/b6e1c277gw1ey7m2dv6fpj201e01e0si.jpg" alt=""></p>
<p>解决完这一波之后，新一波的坑正在到来，亲，你忘了还有正负号呦~<br>然后又得出了：<br>“-e58” -&gt; false<br>“5e+6” -&gt; true<br>“4e+” -&gt; false<br>…</p>
<p>就这样查漏补缺之后，我迎来了我的ACC<br><img src="http://ww3.sinaimg.cn/small/b6e1c277gw1ey7m2eivl2j201g01e3ya.jpg" alt=""></p>
<p>后来我在讨论区看到了这个 ↓<br><img src="http://ww1.sinaimg.cn/mw690/b6e1c277gw1ey7m2gvo48j20hl08w0v9.jpg" alt=""><br>默默点下了vote。。。<br><img src="http://ww3.sinaimg.cn/mw690/b6e1c277gw1ey7m2eqc6oj209a09mgma.jpg" alt=""></p>
<p>最后附上贴满补丁的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       s = s.trim();</span><br><span class="line">       <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'e'</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">'-'</span> || s.charAt(<span class="number">0</span>) == <span class="string">'+'</span>) &#123;</span><br><span class="line">           s = s.substring(<span class="number">1</span>, s.length());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s.charAt(<span class="number">0</span>) == <span class="string">'e'</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">boolean</span> hasPoint = <span class="keyword">false</span>, hasE = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; s.length(); i++) &#123;</span><br><span class="line">           <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">           <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'.'</span> &amp;&amp; !hasPoint &amp;&amp; !hasE) &#123;</span><br><span class="line">               <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; (i == s.length()-<span class="number">1</span> || s.charAt(i+<span class="number">1</span>) == <span class="string">'e'</span>))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               hasPoint = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'e'</span> &amp;&amp; !hasE) &#123;</span><br><span class="line">               <span class="keyword">if</span> (i == s.length()-<span class="number">1</span> || s.charAt(i+<span class="number">1</span>) == <span class="string">'.'</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">if</span> ((s.charAt(i+<span class="number">1</span>) == <span class="string">'+'</span> || s.charAt(i+<span class="number">1</span>) == <span class="string">'-'</span>) &amp;&amp; i != s.length()-<span class="number">2</span>)</span><br><span class="line">                   i++;</span><br><span class="line">               hasE = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://leetcode.com/problems/valid-number/">#65 Valid Number</a></p>
<blockquote>
<p>Validate if a given string is numeric.<br>Some examples:<br>“0” =&gt; true<br>“ 0.1 “ =&gt; true<br>“abc” =&gt; false<br>“1 a” =&gt; false<br>“2e10” =&gt; true<br>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one.</p>
</blockquote>
<p>第一次看到这道题的时候我的表情是这样的 → <img src="http://ww3.sinaimg.cn/mw690/b6e1c277gw1ey7md39mykj202h030glh.jpg" alt=""><br>主要考的应该是归纳能力吧，虽然好像有很多情况的样子，但好好列出来应该也是没问题的吧？<br>too simple too naive<br>]]>
    
    </summary>
    
      <category term="leetcode" scheme="https://blueanana.github.io/tags/leetcode/"/>
    
      <category term="string" scheme="https://blueanana.github.io/tags/string/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Some About Cycle]]></title>
    <link href="https://blueanana.github.io/2015/11/19/SomeAboutCycle/"/>
    <id>https://blueanana.github.io/2015/11/19/SomeAboutCycle/</id>
    <published>2015-11-19T11:34:29.000Z</published>
    <updated>2015-11-20T07:25:16.786Z</updated>
    <content type="html"><![CDATA[<h1 id="判断环">判断环</h1><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="external">#141 Linked List Cycle</a></p>
<blockquote>
<p>Given a linked list, determine if it has a cycle in it.<br>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>设两个指向头部的变量one &amp; two，one每次前进一个节点，two另一个每次前进两个。</p>
<ul>
<li>如果链表中存在环，则最后两个变量都会指向同一个节点。<ul>
<li>设两变量都已在环中，两者相距x步。当one继续走x步时，two走了2x步，这时两者重合。</li>
</ul>
</li>
<li>若果链表中没有环，则最后two的指针会走向链尾null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       ListNode one = head, two = head;</span><br><span class="line">       <span class="keyword">while</span> (two.next != <span class="keyword">null</span> &amp;&amp; two.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           one = one.next;</span><br><span class="line">           two = two.next.next;</span><br><span class="line">           <span class="keyword">if</span> (one == two)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<hr>
<h1 id="找出环的起点">找出环的起点</h1><p><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="external">#142 Linked List Cycle II</a></p>
<blockquote>
<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.<br>Note: Do not modify the linked list.<br>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p><img src="http://ww2.sinaimg.cn/mw690/b6e1c277gw1ey781zeasnj20g209ajrw.jpg" alt=""><br>设链表头部节点与环起始节点的距离为<strong>d</strong>，环的长度为<strong>r</strong>。<br>当one变量走了<strong>k</strong>步时，两变量重合(two走了<strong>2k</strong>步，two领先one <strong>n</strong> 圈)，设此时与环起始节点的距离为<strong>s</strong>。</p>
<ul>
<li>2k - k = nr  -&gt;  k = nr</li>
<li>k = d + s + mr  -&gt;  nr = d + s + mr  -&gt;  d + s = (n - m)r<br>从该式可以看出，从s点处再走d步，就能走完整个环，回到环的起点。<br>s点与链表头到环起始节点的距离都是d步。<br>这时让两个变量分别从s点和链表头走，每次走一步，到两者重合的时候，该点就是环的起始节点了。<br><strong>注意要先判断链表中是否有环</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       ListNode one = head, two = head;</span><br><span class="line">       <span class="keyword">while</span> (two.next != <span class="keyword">null</span> &amp;&amp; two.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           one = one.next;</span><br><span class="line">           two = two.next.next;</span><br><span class="line">           <span class="keyword">if</span> (one == two)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (two.next == <span class="keyword">null</span> || two.next.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       </span><br><span class="line">       one = head;</span><br><span class="line">       <span class="keyword">while</span> (one != two) &#123;</span><br><span class="line">           one = one.next;</span><br><span class="line">           two = two.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> one;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="找出重复的数字">找出重复的数字</h1><p><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="external">#287 Find the Duplicate Number</a></p>
<blockquote>
<p>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.<br>Note:<br>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p>
</blockquote>
<p>这题的标签有two point和binary search两个，对于这种完全乱序的序列，想不到该怎么应用二分法(事实证明是思考角度完全错了)。</p>
<h2 id="two_point">two point</h2><p>这题的思路是上一题的延伸，可以将数组index与value的对应关系转化为链表(感觉好腻害)。</p>
<blockquote>
<p>0 1 2 3 4 5<br> 2 5 5 1 4 3<br>转换成更直观的形式<br>   ↓<br> 1 2 3 4 5 6<br> 2 5 5 1 4 3</p>
</blockquote>
<p><img src="http://ww1.sinaimg.cn/mw690/b6e1c277gw1ey77f4ri1fj20f707wjsc.jpg" alt=""></p>
<p>可以看出，重复的数会有至少两个节点指向它，这将形成环(也可能是自己指向自己，这也是环)。然后这就变成了上面的找环的起始节点的问题了。<br>因为数组中的数一定是小于等于n的，所以可以确定没有任何数会指向n，因此可以拿它做头部节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = nums.length;</span><br><span class="line">       <span class="keyword">int</span> one = len, two = len;</span><br><span class="line">       do &#123;</span><br><span class="line">           one = nums[one-<span class="number">1</span>];</span><br><span class="line">           two = nums[nums[two-<span class="number">1</span>]-<span class="number">1</span>];</span><br><span class="line">       &#125; <span class="keyword">while</span> (one != two);</span><br><span class="line">       one = len;</span><br><span class="line">       <span class="keyword">while</span> (one != two) &#123;</span><br><span class="line">           one = nums[one-<span class="number">1</span>];</span><br><span class="line">           two = nums[two-<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> one;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="binary_search">binary search</h2><p>上面这个做法和二分法并没有半毛钱关系，直到我在讨论区看到了这个 → <a href="https://leetcode.com/discuss/60830/solutions-explanation-space-without-changing-input-array" target="_blank" rel="external">Two Solutions (with explanation): O(nlog(n)) and O(n) time , O(1) space, without changing the input array</a><br>一开始在[1,n]区间中找，得到mid。然后数出数组中所有小于等于mid的数的个数count，若count&gt;mid，说明重复数存在于前半区域中，则下一个搜索区间为[1,mid]，否则为[mid,n]。(耗时)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">1</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">               <span class="keyword">if</span> (nums[i] &lt;= mid)</span><br><span class="line">                   count++;</span><br><span class="line">           <span class="keyword">if</span> (count &gt; mid) right = mid;</span><br><span class="line">           <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>Nice Day ~<br><img src="http://ww2.sinaimg.cn/mw690/b6e1c277gw1ey77gpqrjwj20nz0hstb7.jpg" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="判断环">判断环</h1><p><a href="https://leetcode.com/problems/linked-list-cycle/">#141 Linked List Cycle</a></p>
<blockquote>
<p>Given a linked list, determine if it has a cycle in it.<br>Follow up:<br>Can you solve it without using extra space?</p>
</blockquote>
<p>设两个指向头部的变量one &amp; two，one每次前进一个节点，two另一个每次前进两个。</p>
<ul>
<li>如果链表中存在环，则最后两个变量都会指向同一个节点。<ul>
<li>设两变量都已在环中，两者相距x步。当one继续走x步时，two走了2x步，这时两者重合。</li>
</ul>
</li>
<li>若果链表中没有环，则最后two的指针会走向链尾null。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       ListNode one = head, two = head;</span><br><span class="line">       <span class="keyword">while</span> (two.next != <span class="keyword">null</span> &amp;&amp; two.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">           one = one.next;</span><br><span class="line">           two = two.next.next;</span><br><span class="line">           <span class="keyword">if</span> (one == two)</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="leetcode" scheme="https://blueanana.github.io/tags/leetcode/"/>
    
      <category term="two point" scheme="https://blueanana.github.io/tags/two-point/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Basic Binary Search]]></title>
    <link href="https://blueanana.github.io/2015/11/18/BasicBinarySearch/"/>
    <id>https://blueanana.github.io/2015/11/18/BasicBinarySearch/</id>
    <published>2015-11-18T08:58:04.000Z</published>
    <updated>2015-11-20T07:24:51.663Z</updated>
    <content type="html"><![CDATA[<p>刷了几道二分查找相关的题，稍微总结一下。</p>
<blockquote>
<p><strong>二分查找</strong>是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<br>–wikipedia</p>
</blockquote>
<h1 id="无重复有序数组">无重复有序数组</h1><p>即最基本的二分查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span> <span class="params">(<span class="keyword">int</span>[] nums, target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (target == nums[mid]) retrun mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="微扩展">微扩展</h2><ul>
<li><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="external">#35 Search Insert Position</a></li>
</ul>
<blockquote>
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
</blockquote>
<p>设想循环走到了后期，即left和right分别指向两个相邻的数。这时会先判断left，如果target<nums[left], 则改变right直到跳出循环；如果target="">nums[left]，则left增一，后面改变的只是right值。<br>总之跳出循环后，left指向总是target所在的位置，或是最近的大于target数(即插入位置)的位置，最后返回left即可(同理，right总是指向target或最近的小于target数)。</nums[left],></p>
<ul>
<li>只需要最后返回值语句改为 <strong>return left;</strong></li>
</ul>
<hr>
<h1 id="有重复有序数组">有重复有序数组</h1><ul>
<li><a href="https://leetcode.com/problems/search-for-a-range/" target="_blank" rel="external">#34 Search for a Range</a></li>
</ul>
<blockquote>
<p>Given a sorted array of integers, find the starting and ending position of a given target value.<br>Your algorithm’s runtime complexity must be in the order of O(log n).<br>If the target is not found in the array, return [-1, -1].</p>
</blockquote>
<p>第一版本：通过二分法找到一个与target相等的数组元素，然后向两边扩展，直到边界。</p>
<p>第二版本：<br>当程序运行到target=nums[mid]的情况时，它可能正处于一串重复的元素之中。这时候可能有两种情况：</p>
<ul>
<li>mid就是边界</li>
<li>边界在mid的左边</li>
</ul>
<p>所以需要做的不是返回，而是继续对左边部分做二分查找，直到最后left与right重合，即为起始边界。或者如果目标值不在数组内，则left为最近的大于target数的位置。(e.g. num[] = {1}, target = 0;)<br>至于结束边界，可以反向思考。<br>看到一个复用代码的方式：找target+1的起始边界，target的结束边界为前者减一。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">       <span class="keyword">int</span> start = getBound(nums, target);</span><br><span class="line">       <span class="comment">//注意判断target不在数组中的情况</span></span><br><span class="line">       <span class="keyword">if</span> (start == nums.length || nums[start] != target)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, getBound(nums, target+<span class="number">1</span>)-<span class="number">1</span>&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (target == nums[mid])</span><br><span class="line">               <span class="keyword">if</span> (left == right)<span class="comment">//mid就是边界</span></span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">else</span>              <span class="comment">//边界在mid左边</span></span><br><span class="line">                   right = mid;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> left;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="特殊无序数组">特殊无序数组</h1><p>有一种特殊的无序数组，是一组有序数组在某个点旋转。(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>
<h2 id="无重复">无重复</h2><ul>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="external">Search in Rotated Sorted Array</a></li>
</ul>
<blockquote>
<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.<br>You are given a target value to search. If found in the array return its index, otherwise return -1.<br>You may assume no duplicate exists in the array.</p>
</blockquote>
<p>第一版本：先通过二分查找找到分界pivot，然后判断target处于前半部分还是后半部分，最后对相应部分做二分查找。<br>第二版本：做正常二分查找，并在查找途中进行相应判断。得到mid后，判断left与mid位置值的大小。</p>
<ul>
<li>nums[left] &lt;= nums[mid]，说明左半边是正常序列，即没有pivot。<ul>
<li>判断target是否在左半边序列范围内，若在，则继续对左半边进行查找；(注意范围的定义)</li>
<li>若不在，则查找右半边。</li>
</ul>
</li>
<li>nums[left] &gt; nums[mid]，pivot在左半边。原理与上面相同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                   right = mid-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   left = mid+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                   left = mid+<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   right = mid-<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="有重复">有重复</h2><ul>
<li><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="external">Search in Rotated Sorted Array II</a></li>
</ul>
<blockquote>
<p>Follow up for “Search in Rotated Sorted Array”:<br>What if duplicates are allowed?<br>Write a function to determine if a given target is in the array.</p>
</blockquote>
<p>相比较于无重数组，多了一种特殊情况：e.g. 1111112 -&gt; 1121111 -&gt; 1111211<br>你无法判断pivot在左还是右，甚至是否存在。<br>这时nums[left] == nums[mid]就无法二分了，因为根本不知道往哪个区间二分，这时候只能遍历，直到left遇到一个其他数字，或超出范围。<br>最坏情况：全部都是同一个数的重复数组，O(n)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt; nums[mid]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                   right = mid-<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   left = mid+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">               <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                   left = mid+<span class="number">1</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   right = mid-<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               left++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="总结">总结</h1><p>觉得最重要还是要理清最后left和right指向的到底是什么吧，总是想着想着就乱掉。</p>
<ul>
<li>最后left和right指向两个相邻的数</li>
<li>先判断left，然后是right</li>
<li>right指向的是小于等于target的数</li>
<li>left指向的是大于等于target的数</li>
</ul>
<p>发现有几道应用二分查找的无序数组的题，需要再探索一下。<br>Continue…</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>刷了几道二分查找相关的题，稍微总结一下。</p>
<blockquote>
<p><strong>二分查找</strong>是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。<br>–wikipedia</p>
</blockquote>
<h1 id="无重复有序数组">无重复有序数组</h1><p>即最基本的二分查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span> <span class="params">(<span class="keyword">int</span>[] nums, target)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (target == nums[mid]) retrun mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) right = mid - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> left = mid + <span class="number">1</span>；</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="binary search" scheme="https://blueanana.github.io/tags/binary-search/"/>
    
      <category term="leetcode" scheme="https://blueanana.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown Grammar]]></title>
    <link href="https://blueanana.github.io/2015/11/17/markdown/"/>
    <id>https://blueanana.github.io/2015/11/17/markdown/</id>
    <published>2015-11-17T04:14:11.000Z</published>
    <updated>2015-11-17T04:31:10.206Z</updated>
    <content type="html"><![CDATA[<h2 id="1-Title">1.Title</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># Title <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">## Title <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">### Title <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#### Title <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">##### Title <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">###### Title <span class="number">6</span></span></span><br><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>
<h1 id="Title_1">Title 1</h1><h2 id="Title_2">Title 2</h2><h3 id="Title_3">Title 3</h3><h4 id="Title_4">Title 4</h4><h5 id="Title_5">Title 5</h5><h6 id="Title_6">Title 6</h6><hr>
<a id="more"></a>
<h2 id="2-_Reference">2. Reference</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="operator">Reference</span></span><br><span class="line">&gt;&gt; Nesting <span class="operator">Reference</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Reference</p>
<blockquote>
<p>Nesting Reference</p>
</blockquote>
</blockquote>
<hr>
<h2 id="3-_Font">3. Font</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">*</span>Italics<span class="keyword">*</span></span><br><span class="line">_Italics_</span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>Bold face<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">__Bold face__</span><br><span class="line">~~delete~~</span><br></pre></td></tr></table></figure>
<p><em>Italics</em><br><em>Italics</em><br><strong>Bold face</strong><br><strong>Bold face</strong><br><del>delete</del></p>
<hr>
<h2 id="4-_List">4. List</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>list1</span><br><span class="line">  - nest list1</span><br><span class="line"><span class="code">    - nest nest list</span></span><br><span class="line">  + nest list2</span><br><span class="line">  * nest list3</span><br><span class="line"><span class="bullet">+ </span>list2</span><br><span class="line"><span class="bullet">* </span>list3</span><br><span class="line"><span class="bullet">1. </span>list1</span><br><span class="line"><span class="bullet">1. </span>list2</span><br><span class="line"><span class="bullet">2. </span>list3</span><br></pre></td></tr></table></figure>
<ul>
<li>list1<ul>
<li>nest list1<ul>
<li>nest nest list</li>
</ul>
</li>
</ul>
<ul>
<li>nest list2</li>
</ul>
<ul>
<li>nest list3</li>
</ul>
</li>
</ul>
<ul>
<li>list2</li>
</ul>
<ul>
<li>list3</li>
</ul>
<ol>
<li>list1</li>
<li>list2</li>
<li>list3</li>
</ol>
<hr>
<h2 id="5-_Link">5. Link</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="link_label">Google</span>](<span class="link_url">http://google.com</span>)</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">http:</span>//<span class="attribute">google.com</span>&gt;</span></span></span><br><span class="line">![](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_5BgORGNs3DOYv3eN3oF8mHUpbMrahuwdZV4KedxXCsoHxrh9cQ)</span><br><span class="line"></span><br><span class="line">reference link:</span><br><span class="line">[<span class="link_label">Google</span>][<span class="link_reference">1</span>]</span><br><span class="line">![][2]</span><br><span class="line">[<span class="link_reference">1</span>]:<span class="link_url"> http://google.com</span></span><br><span class="line">[<span class="link_reference">2</span>]:<span class="link_url"> https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_5BgORGNs3DOYv3eN3oF8mHUpbMrahuwdZV4KedxXCsoHxrh9cQ</span></span><br></pre></td></tr></table></figure>
<p><a href="http://google.com" target="_blank" rel="external">Google</a><br><a href="http://google.com" target="_blank" rel="external">http://google.com</a><br><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT_5BgORGNs3DOYv3eN3oF8mHUpbMrahuwdZV4KedxXCsoHxrh9cQ" alt=""></p>
<hr>
<h2 id="6-_code">6. code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7-_form">7. form</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">first</span>|<span class="string">second</span>|<span class="string">third</span>|</span><br><span class="line">|<span class="string">--</span>|<span class="string">:--:</span>|<span class="string">--:</span>|</span><br><span class="line">|<span class="string">1</span>|<span class="string">2</span>|<span class="string">3</span>|</span><br><span class="line">|<span class="string">1</span>|<span class="string">2</span>|<span class="string">3</span>|</span><br><span class="line"><span class="variable">&lt;!-- don't you think the blank is form is useless... !--&gt;</span></span><br><span class="line"><span class="variable">&lt;!-- this form is also ok ↓ --!&gt;</span></span><br><span class="line"></span><br><span class="line">first|<span class="string">second</span>|third</span><br><span class="line">--|<span class="string">:--:</span>|<span class="string">--:</span><br><span class="line">1</span>|<span class="string">2</span>|3</span><br><span class="line">1|<span class="string">2</span>|3</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>first</th>
<th style="text-align:center">second</th>
<th style="text-align:right">third</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">2</td>
<td style="text-align:right">3</td>
</tr>
<tr>
<td>1</td>
<td style="text-align:center">2</td>
<td style="text-align:right">3</td>
</tr>
</tbody>
</table>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-Title">1.Title</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"># Title <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">## Title <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">### Title <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#### Title <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">##### Title <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">###### Title <span class="number">6</span></span></span><br><span class="line">---</span><br><span class="line">***</span><br></pre></td></tr></table></figure>
<h1 id="Title_1">Title 1</h1><h2 id="Title_2">Title 2</h2><h3 id="Title_3">Title 3</h3><h4 id="Title_4">Title 4</h4><h5 id="Title_5">Title 5</h5><h6 id="Title_6">Title 6</h6><hr>]]>
    
    </summary>
    
      <category term="markdown" scheme="https://blueanana.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
